pipeline {
    agent any

    environment {
        APP_NAME           = 'my-java-app'
        DOCKER_IMAGE       = "${APP_NAME}:${BUILD_NUMBER}"
        CONTAINER_NAME     = "test-container-${BUILD_NUMBER}"
        HOST_PORT          = '8083'
        CONTAINER_PORT     = '8080'

        SONAR_HOST_URL     = 'http://13.126.141.57:9000'

        AWS_DEFAULT_REGION = 'ap-south-1'
        ECR_REPO           = 'my-java-app'
        ECS_CLUSTER        = 'my-production-cluster'
        ECS_SERVICE        = 'my-spring-service'

        AWS_CREDENTIAL_ID  = 'aws-credentials'
        GITHUB_CREDENTIALS = 'github-creds'
    }

    stages {

        stage('Checkout') {
            steps {
                git branch: 'feature',
                    url: 'https://github.com/techcoms/backend-springboot-maven-jar.git'
            }
        }

        stage('Build') {
            steps {
                sh 'mvn clean compile'
            }
        }

        stage('Unit Tests') {
            steps {
                sh 'mvn test'
            }
            post {
                always {
                    junit 'target/surefire-reports/*.xml'
                }
            }
        }

        stage('SonarQube Analysis') {
            steps {
                withCredentials([string(credentialsId: 'sonarqube-token', variable: 'SONAR_AUTH_TOKEN')]) {
                    sh """
                        mvn sonar:sonar \
                          -Dsonar.projectKey=spring-boot-demo \
                          -Dsonar.host.url=${SONAR_HOST_URL} \
                          -Dsonar.login=\${SONAR_AUTH_TOKEN}
                    """
                }
            }
        }

        stage('Package') {
            steps {
                sh 'mvn package -DskipTests'
            }
        }

        stage('Build Docker Image') {
            steps {
                sh "docker build -t ${DOCKER_IMAGE} ."
            }
        }

        stage('Test Docker Container') {
            steps {
                script {
                    try {
                        sh """
                            docker run -d --name ${CONTAINER_NAME} \
                            -p ${HOST_PORT}:${CONTAINER_PORT} ${DOCKER_IMAGE}
                        """
                        timeout(time: 3, unit: 'MINUTES') {
                            waitUntil {
                                sh(
                                  script: "curl -s -o /dev/null -w '%{http_code}' http://localhost:${HOST_PORT}/ || echo '000'",
                                  returnStdout: true
                                ).trim() == '200'
                            }
                        }
                    } finally {
                        sh "docker rm -f ${CONTAINER_NAME} || true"
                    }
                }
            }
        }

        stage('Provision Infrastructure (Terraform)') {
            steps {
                withCredentials([
                    usernamePassword(
                        credentialsId: AWS_CREDENTIAL_ID,
                        usernameVariable: 'AWS_ACCESS_KEY_ID',
                        passwordVariable: 'AWS_SECRET_ACCESS_KEY'
                    )
                ]) {
                    sh """
                        set -e
                        echo "Initializing Terraform"
                        terraform init -input=false

                        echo "Planning Infrastructure"
                        terraform plan -out=tfplan -input=false \
                          -var="aws_region=${AWS_DEFAULT_REGION}" \
                          -var="ecr_repo_name=${ECR_REPO}" \
                          -var="ecs_cluster_name=${ECS_CLUSTER}"

                        echo "Applying Infrastructure"
                        terraform apply -auto-approve tfplan
                    """
                }
            }
        }

        stage('Create & Merge Pull Request') {
            when { not { branch 'main' } }
            steps {
                withCredentials([
                    usernamePassword(
                        credentialsId: GITHUB_CREDENTIALS,
                        usernameVariable: 'GITHUB_USER',
                        passwordVariable: 'GITHUB_TOKEN'
                    )
                ]) {
                    sh """
                        gh auth login --with-token <<< "$GITHUB_TOKEN"

                        gh pr create \
                          --base main \
                          --head ${env.BRANCH_NAME} \
                          --title "Merge ${env.BRANCH_NAME} to main" \
                          --body "Automated PR by Jenkins" || true
                    """

                    timeout(time: 10, unit: 'MINUTES') {
                        input message: "Infra verified. Merge to main?"
                    }

                    sh "gh pr merge ${env.BRANCH_NAME} --merge"
                }
            }
        }

        stage('Push Image to ECR') {
            when { branch 'main' }
            steps {
                withCredentials([
                    usernamePassword(
                        credentialsId: AWS_CREDENTIAL_ID,
                        usernameVariable: 'AWS_ACCESS_KEY_ID',
                        passwordVariable: 'AWS_SECRET_ACCESS_KEY'
                    )
                ]) {
                    sh """
                        set -e
                        FULL_REPO_URL=\$(terraform output -raw ecr_repository_url)
                        REGISTRY_DOMAIN=\$(echo \$FULL_REPO_URL | cut -d'/' -f1)

                        aws ecr get-login-password \
                          --region ${AWS_DEFAULT_REGION} \
                        | docker login --username AWS --password-stdin \$REGISTRY_DOMAIN

                        docker tag ${DOCKER_IMAGE} \$FULL_REPO_URL:${BUILD_NUMBER}
                        docker push \$FULL_REPO_URL:${BUILD_NUMBER}

                        docker tag ${DOCKER_IMAGE} \$FULL_REPO_URL:latest
                        docker push \$FULL_REPO_URL:latest
                    """
                }
            }
        }

        stage('Deploy to Production ECS') {
            when { branch 'main' }
            steps {
                withCredentials([
                    usernamePassword(
                        credentialsId: AWS_CREDENTIAL_ID,
                        usernameVariable: 'AWS_ACCESS_KEY_ID',
                        passwordVariable: 'AWS_SECRET_ACCESS_KEY'
                    )
                ]) {
                    sh """
                        aws ecs update-service \
                          --cluster ${ECS_CLUSTER} \
                          --service ${ECS_SERVICE} \
                          --force-new-deployment \
                          --region ${AWS_DEFAULT_REGION}
                    """
                }
            }
        }
    }

    post {
        always {
            cleanWs(deleteDirs: true)
            sh "docker rmi ${DOCKER_IMAGE} || true"
        }
    }
}
