pipeline {
    agent any

    environment {
        // App & Docker
        APP_NAME       = 'my-java-app'
        DOCKER_IMAGE   = "${APP_NAME}:${BUILD_NUMBER}"
        CONTAINER_NAME = "test-container-${BUILD_NUMBER}"
        HOST_PORT      = '8083'
        CONTAINER_PORT = '8080'

        // SonarQube
        SONAR_HOST_URL = 'http://13.126.141.57:9000'

        // AWS
        AWS_DEFAULT_REGION = 'ap-south-1'
        ECS_CLUSTER        = 'my-production-cluster'
        ECS_SERVICE        = 'my-spring-service'
        AWS_CREDENTIAL_ID  = 'aws-credentials'
        ECR_REPOSITORY_URL = '974086408537.dkr.ecr.ap-south-1.amazonaws.com/my-java-app'
        EXECUTION_ROLE_ARN = 'arn:aws:iam::974086408537:role/ecsTaskExecutionRole'
        SUBNETS        = 'subnet-052b895224de0d82a,subnet-09308fb3911c5e2c5'
        SECURITY_GROUP = 'sg-06b52699e83dba266'
    }

    stages {

        stage('Checkout') {
            steps {
                git branch: 'feature',
                    url: 'https://github.com/techcoms/backend-springboot-maven-jar.git'
            }
        }

        stage('Build & Test') {
            steps {
                sh 'mvn clean package'
            }
            post {
                always {
                    junit 'target/surefire-reports/*.xml'
                }
            }
        }

        stage('SonarQube Analysis') {
            steps {
                withCredentials([
                    string(credentialsId: 'sonarqube-token', variable: 'SONAR_AUTH_TOKEN')
                ]) {
                    sh '''
                        mvn sonar:sonar \
                          -Dsonar.projectKey=spring-boot-demo \
                          -Dsonar.host.url=${SONAR_HOST_URL} \
                          -Dsonar.login=${SONAR_AUTH_TOKEN}
                    '''
                }
            }
        }

        stage('Build Docker Image') {
            steps {
                sh "docker build -t ${DOCKER_IMAGE} ."
            }
        }

        stage('Test Docker Container') {
            steps {
                script {
                    try {
                        sh "docker run -d --name ${CONTAINER_NAME} -p ${HOST_PORT}:${CONTAINER_PORT} ${DOCKER_IMAGE}"
                        timeout(time: 2, unit: 'MINUTES') {
                            waitUntil {
                                sh(
                                    script: "curl -s -o /dev/null -w '%{http_code}' http://localhost:${HOST_PORT}/ || echo 000",
                                    returnStdout: true
                                ).trim() == '200'
                            }
                        }
                    } finally {
                        sh "docker rm -f ${CONTAINER_NAME} || true"
                    }
                }
            }
        }

        stage('Provision Infrastructure (Terraform)') {
            steps {
                withCredentials([
                    usernamePassword(
                        credentialsId: AWS_CREDENTIAL_ID,
                        usernameVariable: 'AWS_ACCESS_KEY_ID',
                        passwordVariable: 'AWS_SECRET_ACCESS_KEY'
                    )
                ]) {
                    sh '''
                        set -e
                        terraform init -input=false
                        terraform apply -auto-approve \
                          -var="aws_region=${AWS_DEFAULT_REGION}" \
                          -var="ecs_cluster_name=${ECS_CLUSTER}"
                    '''
                }
            }
        }

        stage('Push to ECR') {
            steps {
                withCredentials([
                    usernamePassword(
                        credentialsId: AWS_CREDENTIAL_ID,
                        usernameVariable: 'AWS_ACCESS_KEY_ID',
                        passwordVariable: 'AWS_SECRET_ACCESS_KEY'
                    )
                ]) {
                    sh '''
                        set -e
                        aws ecr get-login-password --region ${AWS_DEFAULT_REGION} \
                          | docker login --username AWS --password-stdin ${ECR_REPOSITORY_URL%/*}

                        docker tag ${DOCKER_IMAGE} ${ECR_REPOSITORY_URL}:${BUILD_NUMBER}
                        docker tag ${DOCKER_IMAGE} ${ECR_REPOSITORY_URL}:latest

                        docker push ${ECR_REPOSITORY_URL}:${BUILD_NUMBER}
                        docker push ${ECR_REPOSITORY_URL}:latest
                    '''
                }
            }
        }
        stage('Create & Merge Pull Request') {
            when {
                not { branch 'main' }
            }
            steps {
                script {
                    withCredentials([string(credentialsId: 'github-creds', variable: 'GITHUB_TOKEN')]) {
                        sh """
                             echo "Creating PR to merge ${env.BRANCH_NAME} into main..."
                             gh pr create --base main --head ${env.BRANCH_NAME} --title "Merge ${env.BRANCH_NAME} to main" --body "Automated PR created by Jenkins" || echo "PR might already exist"
                        """
                        
                        timeout(time: 10, unit: 'MINUTES') {
                            input message: "Infra verified on ${env.BRANCH_NAME}. Merge to main?"
                        }
                        
                        sh """
                            echo "Merging PR for ${env.BRANCH_NAME}..."
                            gh pr merge ${env.BRANCH_NAME} --merge
                        """
                    }
                }
            }
        }

        stage('Deploy to Production ECS') {
            steps {
                withCredentials([
                    usernamePassword(
                        credentialsId: AWS_CREDENTIAL_ID,
                        usernameVariable: 'AWS_ACCESS_KEY_ID',
                        passwordVariable: 'AWS_SECRET_ACCESS_KEY'
                    )
                ]) {
                    sh '''
                        set -e

                        echo "Registering task definition..."
                        aws ecs register-task-definition \
                          --family ${APP_NAME} \
                          --network-mode awsvpc \
                          --requires-compatibilities FARGATE \
                          --cpu "256" \
                          --memory "512" \
                          --execution-role-arn ${EXECUTION_ROLE_ARN} \
                          --container-definitions "[{
                            \\"name\\":\\"${APP_NAME}\\",
                            \\"image\\":\\"${ECR_REPOSITORY_URL}:${BUILD_NUMBER}\\",
                            \\"portMappings\\":[{\\"containerPort\\":${CONTAINER_PORT}}],
                            \\"essential\\":true
                          }]" \
                          --region ${AWS_DEFAULT_REGION}

                        SERVICE_STATUS=$(aws ecs describe-services \
                          --cluster ${ECS_CLUSTER} \
                          --services ${ECS_SERVICE} \
                          --query 'services[0].status' \
                          --output text \
                          --region ${AWS_DEFAULT_REGION})

                        if [ "$SERVICE_STATUS" = "ACTIVE" ]; then
                            echo "Service exists. Updating..."
                            aws ecs update-service \
                              --cluster ${ECS_CLUSTER} \
                              --service ${ECS_SERVICE} \
                              --task-definition ${APP_NAME} \
                              --force-new-deployment \
                              --region ${AWS_DEFAULT_REGION}
                        else
                            echo "Creating ECS service..."
                            aws ecs create-service \
                              --cluster ${ECS_CLUSTER} \
                              --service-name ${ECS_SERVICE} \
                              --task-definition ${APP_NAME} \
                              --desired-count 1 \
                              --launch-type FARGATE \
                              --network-configuration "awsvpcConfiguration={subnets=[${SUBNETS}],securityGroups=[${SECURITY_GROUP}],assignPublicIp=ENABLED}" \
                              --region ${AWS_DEFAULT_REGION}
                        fi
                    '''
                }
            }
        }
    }

    post {
        always {
            cleanWs(deleteDirs: true)
            sh "docker rmi ${DOCKER_IMAGE} || true"
        }
    }
}
