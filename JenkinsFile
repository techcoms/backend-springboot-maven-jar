pipeline {
    agent any
    
    environment {
        // Application settings
        APP_NAME          = 'my-java-app'
        WAR_FILE          = 'target/*.war'
        // Docker settings
        DOCKER_IMAGE      = "${APP_NAME}:${BUILD_NUMBER}"
        CONTAINER_PORT    = '8080'
        
        // AWS Settings
        AWS_DEFAULT_REGION = 'ap-south-1'
        ECR_REPO           = 'my-java-app'
        ECS_CLUSTER        = 'my-production-cluster'
        ECS_SERVICE        = 'my-spring-service'
        AWS_CREDENTIAL_ID  = 'aws-credentials'
        // Deployment Constants
        EXECUTION_ROLE_ARN = 'arn:aws:iam::974086408537:role/ecsTaskExecutionRole'
        SUBNETS            = 'subnet-052b895224de0d82a,subnet-09308fb3911c5e2c5'
        SECURITY_GROUP     = 'sg-06b52699e83dba266'
    }
    stages {
        stage('Checkout') {
            steps {
                // Checkout main branch
                git branch: "main", url: "https://github.com/techcoms/backend-springboot-maven-jar.git"
            }
        }
        stage('Build & Package') {
            steps {
                sh 'mvn clean package -DskipTests'
            }
        }
        stage('Build Docker Image') {
            steps {
                sh "docker build -t ${DOCKER_IMAGE} ."
            }
        }
        stage('Provision Infrastructure (Terraform)') {
            steps {
                withCredentials([usernamePassword(credentialsId: AWS_CREDENTIAL_ID, passwordVariable: 'AWS_SECRET_ACCESS_KEY', usernameVariable: 'AWS_ACCESS_KEY_ID')]) {
                    sh '''#!/usr/bin/env bash
                        set -euo pipefail
                        echo "Initializing Terraform..."
                        rm -rf .terraform .terraform.lock.hcl || true
                        terraform init -upgrade
                        
                        echo "Applying Infrastructure..."
                        terraform apply -auto-approve \
                          -var="aws_region=${AWS_DEFAULT_REGION}" \
                          -var="ecr_repo_name=${ECR_REPO}" \
                          -var="ecs_cluster_name=${ECS_CLUSTER}"
                    '''
                }
            }
        }
        stage('Push Image to ECR') {
            steps {
                withCredentials([usernamePassword(credentialsId: AWS_CREDENTIAL_ID, passwordVariable: 'AWS_SECRET_ACCESS_KEY', usernameVariable: 'AWS_ACCESS_KEY_ID')]) {
                    sh """
                        echo "Retrieving ECR details from Terraform..."
                        FULL_REPO_URL=\$(terraform output -raw ecr_repository_url)
                        # Extract the registry domain (everything before the first /)
                        REGISTRY_DOMAIN=\$(echo \$FULL_REPO_URL | cut -d'/' -f1)
                        
                        echo "Logging into ECR: \$REGISTRY_DOMAIN"
                        aws ecr get-login-password --region ${AWS_DEFAULT_REGION} | docker login --username AWS --password-stdin \$REGISTRY_DOMAIN
                        
                        echo "Pushing image to \$FULL_REPO_URL..."
                        docker tag ${DOCKER_IMAGE} \$FULL_REPO_URL:${BUILD_NUMBER}
                        docker push \$FULL_REPO_URL:${BUILD_NUMBER}
                        
                        docker tag ${DOCKER_IMAGE} \$FULL_REPO_URL:latest
                        docker push \$FULL_REPO_URL:latest
                    """
                }
            }
        }
        stage('Deploy to Production ECS') {
            steps {
                withCredentials([usernamePassword(credentialsId: AWS_CREDENTIAL_ID, passwordVariable: 'AWS_SECRET_ACCESS_KEY', usernameVariable: 'AWS_ACCESS_KEY_ID')]) {
                    sh """
                        set -e
                        
                        # Dynamic URL retrieval
                        ECR_REPOSITORY_URL=\$(terraform output -raw ecr_repository_url)
                        echo "Registering task definition..."
                        aws ecs register-task-definition \
                          --family ${APP_NAME} \
                          --network-mode awsvpc \
                          --requires-compatibilities FARGATE \
                          --cpu "256" \
                          --memory "512" \
                          --execution-role-arn ${EXECUTION_ROLE_ARN} \
                          --container-definitions "[{
                            \\"name\\":\\"${APP_NAME}\\",
                            \\"image\\":\\"\$ECR_REPOSITORY_URL:${BUILD_NUMBER}\\",
                            \\"portMappings\\":[{\\"containerPort\\":${CONTAINER_PORT}}],
                            \\"essential\\":true
                          }]" \
                          --region ${AWS_DEFAULT_REGION}
                        SERVICE_STATUS=\$(aws ecs describe-services \
                          --cluster ${ECS_CLUSTER} \
                          --services ${ECS_SERVICE} \
                          --query 'services[0].status' \
                          --output text \
                          --region ${AWS_DEFAULT_REGION})
                        if [ "\$SERVICE_STATUS" = "ACTIVE" ]; then
                            echo "Service exists. Updating..."
                            aws ecs update-service \
                              --cluster ${ECS_CLUSTER} \
                              --service ${ECS_SERVICE} \
                              --task-definition ${APP_NAME} \
                              --force-new-deployment \
                              --region ${AWS_DEFAULT_REGION}
                        else
                            echo "Creating ECS service..."
                            aws ecs create-service \
                              --cluster ${ECS_CLUSTER} \
                              --service-name ${ECS_SERVICE} \
                              --task-definition ${APP_NAME} \
                              --desired-count 1 \
                              --launch-type FARGATE \
                              --network-configuration "awsvpcConfiguration={subnets=[${SUBNETS}],securityGroups=[${SECURITY_GROUP}],assignPublicIp=ENABLED}" \
                              --region ${AWS_DEFAULT_REGION}
                        fi
                    """
                }
            }
        }
    }
    post {
        always {
            cleanWs(deleteDirs: true)
            sh 'docker rmi ${DOCKER_IMAGE} || true'
        }
    }
}
